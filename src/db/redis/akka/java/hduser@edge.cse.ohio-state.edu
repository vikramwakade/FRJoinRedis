package db.redis.akka.java;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import scala.concurrent.Future;
import scala.concurrent.duration.Duration;
import akka.util.Timeout;
import scala.concurrent.Await;
import akka.actor.ActorRef;
import akka.actor.UntypedActor;
import akka.dispatch.Futures;
import akka.dispatch.Mapper;
import akka.pattern.Patterns;
import redis.clients.jedis.*;

import db.redis.akka.java.msgs.*;

public class SlaveActor extends UntypedActor {
    Jedis conn;  
    BroadcastTable bTable;
    
    public void preStart() {
    	bTable = new BroadcastTable();
    	conn = new Jedis("localhost");
    }
    
    public void postStop() {
    	
    }
    
    @Override
    public void onReceive(Object message) throws Exception {
        	
    	if (message.equals("GET_CATALOG")) {
			// <tableName, Length>
			Map<String, Long> result = new HashMap<String, Long>();
            
            Jedis conn = new Jedis("localhost");
            
            List<String> schema = conn.lrange("schema", 0, -1);
            for (String tableName : schema) {
            	String col = conn.lindex(tableName+":columns", 0);
            	result.put(tableName, conn.llen(tableName+":"+col));
            	System.out.println(tableName + " " + conn.llen(tableName+":"+col));
            }
            
            System.out.println("Sending response from host : " + getSelf().toString() +
            		"\nTo : " + getSender().toString());
            getSender().tell(new CatalogResponse(getSelf(), result), getSelf());
    	}
    	else if (message instanceof BroadcastCommand) {
    		
    		BroadcastCommand br = (BroadcastCommand) message;
    		String tableName = br.getTableName();
    		
    		String joinColumnName = br.getJoinColumnName();
    		List<String> columnNames = br.getColumnNames();
    		List<List<String>> table = new ArrayList<List<String>>();
    		
    		for (String c : columnNames) {
    			List<String> val = new ArrayList<String>();
    			val = conn.lrange(tableName+":"+c, 0, -1);
    			table.add(val);
    		}
    		
    		// if the join column is not in the list of columns expected in the result
    		if (!columnNames.contains(joinColumnName)) {
    			System.out.println("Join column not in the result list");
    			List<String> val = new ArrayList<String>();
    			val = conn.lrange(tableName+":"+joinColumnName, 0, -1);
    			table.add(val);
    		}
    		
    		BroadcastTable bt = new BroadcastTable(tableName, joinColumnName, columnNames, table);
    		List<ActorRef> remoteActors = br.getRemoteActors();
    		
    		// future objects to wait for the broadcast table to be received by every node
    		List<Future<Object>> futures = new ArrayList<Future<Object>>();
    		Timeout timeout = new Timeout(Duration.create(1000, "seconds"));
    		
    		if (remoteActors.contains(getSelf())) {
    			remoteActors.remove(getSelf());
    			bTable = bt;
    		}
    		for (ActorRef actor : remoteActors) {
    			System.out.println("Sending smaller table to : " + actor.toString());
    			futures.add(Patterns.ask(actor, bt, timeout));
    		}
    		
    		Future<Iterable<Object>> futureSeq = Futures.sequence(futures,
    				getContext().system().dispatcher());
    		
    		Future<Integer> futureResult = futureSeq.map(
    				new Mapper<Iterable<Object>, Integer>() {
    					
    					public Integer apply(Iterable<Object> objs) {
    						Integer count = new Integer(0);
    						
    						for (Object obj : objs) {
    							String rs = (String) obj;
    							if (rs.equals("SUCCESS")) {
    								count = count + 1;
    								System.out.println("\nTable received by " + getSender());
    							}
    						}
    						
    						return count;
    					}
    				}
    				, getContext().system().dispatcher());
    		
    		if (remoteActors.size() == Await.result(futureResult, timeout.duration())) {
    			getSender().tell("SUCCESS", getSelf());
    		}
    	}
    	else if (message instanceof BroadcastTable) {
    		if (!getSelf().equals(getSender())) {
	    		System.out.println("Broadcast Table received from : " + getSender().toString() + "\n By : " + getSelf().toString());
	    		bTable = (BroadcastTable) message;
    		}
    		// SUCCCESS message sent to the sender
    		System.out.println("Sending SUCCESS msg to " + getSender().toString());
    		getSender().tell("SUCCESS", getSelf());
    	}
        else if (message instanceof JoinQuery) {
            JoinQuery join = (JoinQuery) message;
            
            List<String> result = Join(join.getTable1(), join.getTable2(), join.getT1_columns()
            		, join.getT2_columns(), join.getJoinType(), join.getPr());
            
            System.out.println("Result Size : " + result.size()/7);
            getSender().tell(result, getSelf());
        }
        else {
            System.out.println("Server Actor unhandled message received");
            unhandled(message);
        }
    }
    
    public List<String> Join(String t1, String t2, List<String> c1, List<String> c2, String type, Predicate p) {
    	List<String> t1_columns = c1;
    	List<String> t2_columns = bTable.getColumnNames();
		
		List<String> result = new ArrayList<String>();
		
		List<List<String>> table1 = new ArrayList<List<String>>();
		List<List<String>> table2 = null;
		
		System.out.println(" Size : " + this.bTable.getTable().size());
		if (t2.equals(bTable.getTableName())) {
			table2 = bTable.getTable();
		}
		else {
			System.out.println("Table2 name different than expected");
			return null;
		}
		
		for (String c : t1_columns) {
			List<String> val = new ArrayList<String>();
			val = conn.lrange(t1+":"+c, 0, -1);
			table1.add(val);
		}
		
		// if the join column is not in the list of columns expected in the result
		if (!c1.contains(p.getTable1_column())) {
			List<String> val = new ArrayList<String>();
			val = conn.lrange(t1+":"+p.getTable1_column(), 0, -1);
			table1.add(val);
		}
		
		//check if col name given in join function exists in table. if so get its index ie offset from start of row
	    int c1_index = -1, c2_index = -1;
	    if (t1_columns.contains(p.getTable1_column()))
	    	c1_index = t1_columns.indexOf(p.getTable1_column());
	    else
	    	c1_index = table1.size() - 1;
	    
	    if (t2_columns.contains(p.getTable2_column()))
	    	c2_index = t2_columns.indexOf(p.getTable2_column());
	    else
	    	c2_index = table2.size() - 1;
	    
	    // t1_columns and t2_columns contain the actual column names expected in the result
	    // table1 and table2 also contain the join columns
	    System.out.println("c1 index : " + c1_index + "\nc2 index : " + c2_index);
	    for (int i = 0; i < table1.get(c1_index).size(); i++) {
	    	for (int j = 0; j < table2.get(c2_index).size(); j++) {
	    		if (table1.get(c1_index).get(i).equals(table2.get(c2_index).get(j))) {
	    			for (int k = 0; k < t1_columns.size(); k++) {
	    				// adding all elements of the corresponding row of table 1
	    				result.add((String) table1.get(k).get(i));
	    			}
	    			for (int l = 0; l < t2_columns.size(); l++) {
	    				// adding all elements of the corresponding row of table 2
	    				result.add((String) table2.get(l).get(j));
	    			}
	    		}
	    	}
	    }
		
		return result;
	}
    
	public List<String> Join_RS(Jedis conn, String t1, String t2, String type, Predicate p, int table1_no) {
        
        //get entire lists ie logs:1 & customer:1
        List<String> table1 = conn.lrange(t1+":"+table1_no, 0, -1);
        List<String> table2 = conn.lrange(t2+":1", 0, -1);
        //result index
        List<String> result = new ArrayList<String>();
        
        //check if col name given in join function exists in table. if so get its index ie offset from start of row
        int c1_index = -1, c2_index = -1;
        List<String> t1_columns = conn.lrange(t1+":columns", 0, -1);
        List<String> t2_columns = conn.lrange(t2+":columns", 0, -1);
        for (int i = 0; i < t1_columns.size(); i++) {
            if (t1_columns.get(i).equals(p.getTable1_column())) {
                c1_index = i;//offset from start of row
                break;
            }
        }
        for (int i = 0; i < t2_columns.size(); i++) {
            if (t2_columns.get(i).equals(p.getTable2_column())) {
                c2_index = i;    //offset from start of row
                break;
            }
        }
        if (c1_index == -1 || c2_index == -1) {    
            System.out.println("Column not present in the table");
            return null;
        }      
        
        int t1_col = t1_columns.size();
        int t2_col = t2_columns.size();
        int len1 = table1.size();   //~~ #rows in table1
        int len2 = table2.size();   //~~#rows in table2
        
        for (int i = 0; i < len1; i+=t1_col) {
            for (int j = 0; j < len2; j+=t2_col) {
                if (table1.get(i + c1_index).equals(table2.get(j + c2_index))) {
                    //System.out.println(table1.get(i + c1_index) + " " + table2.get(j + c2_index));
                    for (int k = i; k < i+t1_col; k++) {
                        result.add(table1.get(k));
                    }
                    for (int l = j; l < j+t2_col; l++) {
                        result.add(table2.get(l));
                    }
                }
            }
            
        }
        
        return result;
    }
    
    public List<ArrayList<String>> Join_HT(Jedis conn, String t1, String t2, String type, Predicate p) {
        Set<String> t1_rows = conn.smembers(t1 + ":rowids");
        Set<String> t2_rows = conn.smembers(t2 + ":rowids");
        
        List<ArrayList<String>> result = new ArrayList<ArrayList<String>>();        
        List<String> t1_columns = new ArrayList<String>();
        List<String> t2_columns = new ArrayList<String>();
        
        t1_columns = conn.lrange(t1, 0, -1);
        t2_columns = conn.lrange(t2, 0, -1);
        
        for (String m : t1_rows) {
            for (String n : t2_rows) {
                String c1 = conn.hget(t1+":row:"+m, p.getTable1_column());
                String c2 = conn.hget(t2+":row:"+n, p.getTable2_column());
                
                if (c1.equals(c2)) {
                    ArrayList<String> row = new ArrayList<String>();
                    
                    Map<String, String> map1 = conn.hgetAll(t1+":row:"+m);
                    Map<String, String> map2 = conn.hgetAll(t2+":row:"+n);
                    
                    for (Object key : t1_columns)
                        row.add(map1.get((String)key));
                    for (Object key : t2_columns)
                        row.add(map2.get((String)key));
                    
                    result.add(row);
                }
            }
        }
        
        return result;
        
    }
}